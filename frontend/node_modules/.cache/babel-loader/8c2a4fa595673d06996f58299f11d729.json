{"ast":null,"code":"var _jsxFileName = \"/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx\";\nimport React, { useEffect, useRef } from \"react\";\nimport { config } from \"../misc/canvasConfig\";\nimport CanvasGrid from \"../misc/canvasGrid\";\nimport Piece from \"../misc/Piece\"; //import Swipeable from 'react-swipeable'\n\nfunction controls(key, piece, grid, context) {\n  if (key === \"ArrowUp\") piece.rotate();\n  if (key === \"ArrowLeft\") piece.moveLeft();\n  if (key === \"ArrowRight\") piece.moveRight();\n  if (key === \"ArrowDown\") piece.moveDown();\n  if (key === \"l\") piece.lock();\n  if (key === \"p\") grid.penalty(piece);\n  if (key === \"n\") newPiece(context, grid);\n  /*if (key === onSwipedUp) piece.rotate()\n  if (key === onSwipedLeft) piece.moveLeft()\n  PropTypes.func,\n  \tonSwipedRight: PropTypes.func,\n  \tonSwipedDown: PropTypes.func,\n  \tonSwipedLeft: PropTypes.func,onSwip)*/\n} //function mobile_controls(onSwiped, piec)\n\n\nfunction newPiece(context, grid) {\n  if (!context || !grid) return null;\n  let pieceNum = Math.floor(Math.random() * pieces.length);\n  let pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length);\n  console.log(pieceNum, pieceVariant);\n  let newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1]);\n  newPiece.active = pieceVariant;\n  let [y, x] = pieceStartPosition(pieceNum, pieceVariant);\n  newPiece.x = x;\n  newPiece.y = y;\n  newPiece.draw();\n  if (newPiece.isCollition(x, y, pieceVariant)) return null;\n  return newPiece;\n}\n\nconst GameCanvas = props => {\n  const GameCanvas = ({\n    grid,\n    currentPiece,\n    setCurrentPiece,\n    setGrid,\n    setGameOver,\n    context,\n    setContext,\n    getNextPiece\n  }) => {\n    const canvasRef = useRef(null);\n    useEffect(() => {\n      if (canvasRef.current) {\n        const renderCtx = canvasRef.current.getContext(\"2d\");\n\n        if (renderCtx) {\n          setContext(renderCtx);\n        }\n      }\n    }, [context, setContext]);\n    useEffect(() => {\n      if (context) {\n        if (!grid) {\n          let gr = new CanvasGrid(context);\n          gr.init();\n          setGrid(gr);\n        } else {\n          // console.log(\"grid already exist\")\n          // grid.draw()\n          if (!currentPiece) {\n            console.log(\"request for a new piece\");\n            getNextPiece();\n          }\n        }\n      }\n\n      return () => {};\n    }, [context, grid, currentPiece, setCurrentPiece, setGrid, getNextPiece]);\n    useEffect(() => {\n      const interval = setInterval(() => {\n        if (currentPiece) if (!currentPiece.moveDown()) {\n          currentPiece.lock();\n          grid.removeFilledLines();\n          grid.draw();\n          getNextPiece();\n        }\n      }, 1000);\n      return () => clearInterval(interval);\n    }, [currentPiece, context, grid, setGameOver, setCurrentPiece, setContext, getNextPiece]);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        textAlign: \"center\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 97,\n        columnNumber: 4\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      id: \"canvas\",\n      ref: canvasRef,\n      width: config.COLS * config.BLOCK,\n      height: config.ROWS * config.BLOCK,\n      style: {\n        border: \"2px solid #000\",\n        marginTop: 10\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 101,\n        columnNumber: 5\n      }\n    }));\n  };\n};\n\nexport default GameCanvas;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx"],"names":["React","useEffect","useRef","config","CanvasGrid","Piece","controls","key","piece","grid","context","rotate","moveLeft","moveRight","moveDown","lock","penalty","newPiece","pieceNum","Math","floor","random","pieces","length","pieceVariant","console","log","active","y","x","pieceStartPosition","draw","isCollition","GameCanvas","props","currentPiece","setCurrentPiece","setGrid","setGameOver","setContext","getNextPiece","canvasRef","current","renderCtx","getContext","gr","init","interval","setInterval","removeFilledLines","clearInterval","textAlign","COLS","BLOCK","ROWS","border","marginTop"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef } from \"react\"\nimport { config } from \"../misc/canvasConfig\"\nimport CanvasGrid from \"../misc/canvasGrid\"\nimport Piece from \"../misc/Piece\"\n//import Swipeable from 'react-swipeable'\n\nfunction controls(key, piece, grid, context) {\n\tif (key === \"ArrowUp\") piece.rotate()\n\tif (key === \"ArrowLeft\") piece.moveLeft()\n\tif (key === \"ArrowRight\") piece.moveRight()\n\tif (key === \"ArrowDown\") piece.moveDown()\n\tif (key === \"l\") piece.lock()\n\tif (key === \"p\") grid.penalty(piece)\n\tif (key === \"n\") newPiece(context, grid)\n\t/*if (key === onSwipedUp) piece.rotate()\n\tif (key === onSwipedLeft) piece.moveLeft()\n\tPropTypes.func,\n\t\tonSwipedRight: PropTypes.func,\n\t\tonSwipedDown: PropTypes.func,\n\t\tonSwipedLeft: PropTypes.func,onSwip)*/\n}\n\n//function mobile_controls(onSwiped, piec)\n\nfunction newPiece(context, grid) {\n\tif (!context || !grid) return null\n\n\tlet pieceNum = Math.floor(Math.random() * pieces.length)\n\tlet pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length)\n\tconsole.log(pieceNum, pieceVariant)\n\tlet newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1])\n\n\tnewPiece.active = pieceVariant\n\tlet [y, x] = pieceStartPosition(pieceNum, pieceVariant)\n\tnewPiece.x = x\n\tnewPiece.y = y\n\tnewPiece.draw()\n\tif (newPiece.isCollition(x, y, pieceVariant)) return null\n\treturn newPiece\n}\n\nconst GameCanvas = (props) => {\n\tconst GameCanvas = ({\n\t\tgrid,\n\t\tcurrentPiece,\n\t\tsetCurrentPiece,\n\t\tsetGrid,\n\t\tsetGameOver,\n\t\tcontext,\n\t\tsetContext,\n\t\tgetNextPiece,\n\t}) => {\n\t\tconst canvasRef = useRef(null)\n\n\t\tuseEffect(() => {\n\t\t\tif (canvasRef.current) {\n\t\t\t\tconst renderCtx = canvasRef.current.getContext(\"2d\")\n\n\t\t\t\tif (renderCtx) {\n\t\t\t\t\tsetContext(renderCtx)\n\t\t\t\t}\n\t\t\t}\n\t\t}, [context, setContext])\n\n\t\tuseEffect(() => {\n\t\t\tif (context) {\n\t\t\t\tif (!grid) {\n\t\t\t\t\tlet gr = new CanvasGrid(context)\n\t\t\t\t\tgr.init()\n\t\t\t\t\tsetGrid(gr)\n\t\t\t\t} else {\n\t\t\t\t\t// console.log(\"grid already exist\")\n\t\t\t\t\t// grid.draw()\n\t\t\t\t\tif (!currentPiece) {\n\t\t\t\t\t\tconsole.log(\"request for a new piece\")\n\t\t\t\t\t\tgetNextPiece()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn () => {}\n\t\t}, [context, grid, currentPiece, setCurrentPiece, setGrid, getNextPiece])\n\n\t\tuseEffect(() => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (currentPiece)\n\t\t\t\t\tif (!currentPiece.moveDown()) {\n\t\t\t\t\t\tcurrentPiece.lock()\n\t\t\t\t\t\tgrid.removeFilledLines()\n\t\t\t\t\t\tgrid.draw()\n\t\t\t\t\t\tgetNextPiece()\n\t\t\t\t\t}\n\t\t\t}, 1000)\n\t\t\treturn () => clearInterval(interval)\n\t\t}, [currentPiece, context, grid, setGameOver, setCurrentPiece, setContext, getNextPiece])\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t}}>\n\t\t\t\t<canvas\n\t\t\t\t\tid=\"canvas\"\n\t\t\t\t\tref={canvasRef}\n\t\t\t\t\twidth={config.COLS * config.BLOCK}\n\t\t\t\t\theight={config.ROWS * config.BLOCK}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tborder: \"2px solid #000\",\n\t\t\t\t\t\tmarginTop: 10,\n\t\t\t\t\t}}></canvas>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default GameCanvas\n"]},"metadata":{},"sourceType":"module"}