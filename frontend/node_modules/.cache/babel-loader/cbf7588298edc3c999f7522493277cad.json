{"ast":null,"code":"import { config } from \"./canvasConfig\";\nimport drawBlock from \"./drawBlock\";\nimport { pieces, pieceStartPosition } from \"./pieces\";\n/***\n * Tetramino Class\n */\n\nfunction Piece(context, grid, piece, colour) {\n  this.piece = piece;\n  this.colour = colour;\n  this.active = 0;\n  this.x = 0;\n  this.y = 0;\n  this.context = context;\n  this.grid = grid;\n\n  this.draw = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, this.colour);\n      }\n    }\n  };\n\n  this.clear = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, config.EMPTY_BG);\n      }\n    }\n  };\n\n  this.lock = () => {\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) grid.coords[this.y + row][this.x + col] = this.colour;\n      }\n    }\n  };\n\n  this.rotate = () => {\n    if (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 2;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    }\n  };\n\n  this.moveLeft = () => {\n    if (!this.isCollition(this.x - 1)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.draw();\n    }\n  };\n\n  this.moveRight = () => {\n    if (!this.isCollition(this.x + 1)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.draw();\n    }\n  };\n\n  this.moveDown = () => {\n    if (!this.isCollition(this.x, this.y + 1)) {\n      this.clear();\n      this.y = this.y + 1;\n      this.draw();\n      return true;\n    }\n\n    return false;\n  };\n\n  this.isCollition = (newX = this.x, newY = this.y, newState = this.active) => {\n    for (let row = 0; row < this.piece[newState].length; row++) {\n      for (let col = 0; col < this.piece[newState][row].length; col++) {\n        if (this.piece[newState][row][col]) {\n          if (newX + col < 0 || newX + col >= config.COLS || newY + row >= config.ROWS) {\n            console.log(\"collision\");\n            return true;\n          }\n\n          if (this.grid.coords[newY + row][newX + col] !== config.EMPTY_BG) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n}\n\nfunction newPiece(context, grid) {\n  if (!context || !grid) return null;\n  let pieceNum = Math.floor(Math.random() * pieces.length);\n  let pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length);\n  console.log(pieceNum, pieceVariant);\n  let newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1]);\n  newPiece.active = pieceVariant;\n  let [y, x] = pieceStartPosition(pieceNum, pieceVariant);\n  newPiece.x = x;\n  newPiece.y = y;\n  newPiece.draw();\n  if (newPiece.isCollition(x, y, pieceVariant)) return null;\n  return newPiece;\n}\n\nexport { newPiece };\nexport default Piece;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/misc/Piece.js"],"names":["config","drawBlock","pieces","pieceStartPosition","Piece","context","grid","piece","colour","active","x","y","draw","row","length","col","clear","EMPTY_BG","lock","coords","rotate","isCollition","moveLeft","moveRight","moveDown","newX","newY","newState","COLS","ROWS","console","log","newPiece","pieceNum","Math","floor","random","pieceVariant"],"mappings":"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","sourcesContent":["import { config } from \"./canvasConfig\"\nimport drawBlock from \"./drawBlock\"\nimport { pieces, pieceStartPosition } from \"./pieces\"\n/***\n * Tetramino Class\n */\n\nfunction Piece(context, grid, piece, colour) {\n\tthis.piece = piece\n\tthis.colour = colour\n\tthis.active = 0\n\tthis.x = 0\n\tthis.y = 0\n\tthis.context = context\n\tthis.grid = grid\n\n\tthis.draw = (active = this.active) => {\n\t\tthis.active = active\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, this.colour)\n\t\t\t}\n\t\t}\n\t}\n\tthis.clear = (active = this.active) => {\n\t\tthis.active = active\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col])\n\t\t\t\t\tdrawBlock(this.context, this.x + col, this.y + row, config.EMPTY_BG)\n\t\t\t}\n\t\t}\n\t}\n\tthis.lock = () => {\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col]) grid.coords[this.y + row][this.x + col] = this.colour\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.rotate = () => {\n\t\tif (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x + 1\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 1\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 2\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveLeft = () => {\n\t\tif (!this.isCollition(this.x - 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 1\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveRight = () => {\n\t\tif (!this.isCollition(this.x + 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x + 1\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveDown = () => {\n\t\tif (!this.isCollition(this.x, this.y + 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.y = this.y + 1\n\t\t\tthis.draw()\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tthis.isCollition = (newX = this.x, newY = this.y, newState = this.active) => {\n\t\tfor (let row = 0; row < this.piece[newState].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[newState][row].length; col++) {\n\t\t\t\tif (this.piece[newState][row][col]) {\n\t\t\t\t\tif (newX + col < 0 || newX + col >= config.COLS || newY + row >= config.ROWS) {\n\t\t\t\t\t\tconsole.log(\"collision\")\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tif (this.grid.coords[newY + row][newX + col] !== config.EMPTY_BG) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n}\n\nfunction newPiece(context, grid) {\n\tif (!context || !grid) return null\n\n\tlet pieceNum = Math.floor(Math.random() * pieces.length)\n\tlet pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length)\n\tconsole.log(pieceNum, pieceVariant)\n\tlet newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1])\n\n\tnewPiece.active = pieceVariant\n\tlet [y, x] = pieceStartPosition(pieceNum, pieceVariant)\n\tnewPiece.x = x\n\tnewPiece.y = y\n\tnewPiece.draw()\n\tif (newPiece.isCollition(x, y, pieceVariant)) return null\n\treturn newPiece\n}\n\nexport { newPiece }\nexport default Piece\n"]},"metadata":{},"sourceType":"module"}