{"ast":null,"code":"var _jsxFileName = \"/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { config } from \"../misc/canvasConfig\";\nimport CanvasGrid from \"../misc/canvasGrid\";\nimport controls from \"../misc/controls\";\n\nconst GameCanvas = ({\n  grid,\n  currentPiece,\n  setCurrentPiece,\n  setGrid,\n  setGameOver,\n  context,\n  setContext,\n  getNextPiece,\n  gameOver\n}) => {\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderCtx = canvasRef.current.getContext(\"2d\");\n\n      if (renderCtx) {\n        setContext(renderCtx);\n      }\n    }\n\n    return () => {\n      console.log(\"i wonder when is this cleanup happening....\");\n      if (gameOver) canvasRef.current = null;\n    };\n  }, [context, setContext]);\n  useEffect(() => {\n    if (context) {\n      if (!grid) {\n        let gr = new CanvasGrid(context);\n        gr.init();\n        setGrid(gr);\n      } else {\n        // console.log(\"grid already exist\")\n        if (!currentPiece) {\n          console.log(\"request for a new piece\");\n          getNextPiece();\n        }\n      }\n    }\n\n    return () => {\n      console.log(\"this is where the cleanup stuff happens\");\n    };\n  }, [context, grid, currentPiece, setCurrentPiece, setGrid, getNextPiece]);\n  useEffect(() => {\n    const handleKeyPress = ({\n      key\n    }) => controls(key, currentPiece, grid, context);\n\n    if (currentPiece) {\n      document.addEventListener(\"keydown\", handleKeyPress);\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyPress);\n    };\n  }, [currentPiece, grid, context]);\n  const [seconds, setSeconds] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(seconds => seconds + 1);\n      if (currentPiece) if (!currentPiece.moveDown()) {\n        currentPiece.lock();\n        grid.removeFilledLines();\n        getNextPiece();\n        setSeconds(0);\n        console.log(\"lock current piece and request for the next piece\");\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [currentPiece, context, grid, setGameOver, setCurrentPiece, setContext, getNextPiece]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      textAlign: \"center\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 4\n    }\n  }, seconds, \" seconds since mount\"), /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    ref: canvasRef,\n    width: config.COLS * config.BLOCK,\n    height: config.ROWS * config.BLOCK,\n    style: {\n      border: \"2px solid #000\",\n      marginTop: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 4\n    }\n  }));\n};\n\nexport default GameCanvas;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx"],"names":["React","useEffect","useState","useRef","config","CanvasGrid","controls","GameCanvas","grid","currentPiece","setCurrentPiece","setGrid","setGameOver","context","setContext","getNextPiece","gameOver","canvasRef","current","renderCtx","getContext","console","log","gr","init","handleKeyPress","key","document","addEventListener","removeEventListener","seconds","setSeconds","interval","setInterval","moveDown","lock","removeFilledLines","clearInterval","textAlign","COLS","BLOCK","ROWS","border","marginTop"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useRef } from \"react\"\nimport { config } from \"../misc/canvasConfig\"\nimport CanvasGrid from \"../misc/canvasGrid\"\nimport controls from \"../misc/controls\"\n\nconst GameCanvas = ({\n\tgrid,\n\tcurrentPiece,\n\tsetCurrentPiece,\n\tsetGrid,\n\tsetGameOver,\n\tcontext,\n\tsetContext,\n\tgetNextPiece,\n\tgameOver,\n}) => {\n\tconst canvasRef = useRef(null)\n\n\tuseEffect(() => {\n\t\tif (canvasRef.current) {\n\t\t\tconst renderCtx = canvasRef.current.getContext(\"2d\")\n\n\t\t\tif (renderCtx) {\n\t\t\t\tsetContext(renderCtx)\n\t\t\t}\n\t\t}\n\n\t\treturn () => {\n\t\t\tconsole.log(\"i wonder when is this cleanup happening....\")\n\t\t\tif (gameOver) canvasRef.current = null\n\t\t}\n\t}, [context, setContext])\n\n\tuseEffect(() => {\n\t\tif (context) {\n\t\t\tif (!grid) {\n\t\t\t\tlet gr = new CanvasGrid(context)\n\t\t\t\tgr.init()\n\t\t\t\tsetGrid(gr)\n\t\t\t} else {\n\t\t\t\t// console.log(\"grid already exist\")\n\n\t\t\t\tif (!currentPiece) {\n\t\t\t\t\tconsole.log(\"request for a new piece\")\n\t\t\t\t\tgetNextPiece()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\tconsole.log(\"this is where the cleanup stuff happens\")\n\t\t}\n\t}, [context, grid, currentPiece, setCurrentPiece, setGrid, getNextPiece])\n\n\tuseEffect(() => {\n\t\tconst handleKeyPress = ({ key }) => controls(key, currentPiece, grid, context)\n\t\tif (currentPiece) {\n\t\t\tdocument.addEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t}, [currentPiece, grid, context])\n\n\tconst [seconds, setSeconds] = useState(0)\n\n\tuseEffect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tsetSeconds((seconds) => seconds + 1)\n\t\t\tif (currentPiece)\n\t\t\t\tif (!currentPiece.moveDown()) {\n\t\t\t\t\tcurrentPiece.lock()\n\t\t\t\t\tgrid.removeFilledLines()\n\t\t\t\t\tgetNextPiece()\n\t\t\t\t\tsetSeconds(0)\n\t\t\t\t\tconsole.log(\"lock current piece and request for the next piece\")\n\t\t\t\t}\n\t\t}, 1000)\n\t\treturn () => clearInterval(interval)\n\t}, [currentPiece, context, grid, setGameOver, setCurrentPiece, setContext, getNextPiece])\n\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\ttextAlign: \"center\",\n\t\t\t}}>\n\t\t\t<h3>{seconds} seconds since mount</h3>\n\t\t\t<canvas\n\t\t\t\tid=\"canvas\"\n\t\t\t\tref={canvasRef}\n\t\t\t\twidth={config.COLS * config.BLOCK}\n\t\t\t\theight={config.ROWS * config.BLOCK}\n\t\t\t\tstyle={{\n\t\t\t\t\tborder: \"2px solid #000\",\n\t\t\t\t\tmarginTop: 10,\n\t\t\t\t}}></canvas>\n\t\t</div>\n\t)\n}\n\nexport default GameCanvas\n"]},"metadata":{},"sourceType":"module"}