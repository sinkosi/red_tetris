{"ast":null,"code":"var _jsxFileName = \"/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { pieces, pieceStartPosition } from \"../misc/pieces\";\nimport { config } from \"../misc/canvasConfig\";\nimport CanvasGrid from \"../misc/canvasGrid\";\nimport Piece from \"../misc/Piece\";\n\nfunction controls(key, piece, grid, context) {\n  if (key === \"ArrowUp\") piece.rotate();\n  if (key === \"ArrowLeft\") piece.moveLeft();\n  if (key === \"ArrowRight\") piece.moveRight();\n  if (key === \"ArrowDown\") piece.moveDown();\n  if (key === \"l\") piece.lock();\n  if (key === \"p\") grid.penalty(piece);\n  if (key === \"n\") newPiece(context, grid);\n}\n\nfunction newPiece(context, grid) {\n  if (!context || !grid) return null;\n  let pieceNum = Math.floor(Math.random() * pieces.length);\n  let pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length);\n  console.log(pieceNum, pieceVariant);\n  let newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1]);\n  newPiece.active = pieceVariant;\n  let [y, x] = pieceStartPosition(pieceNum, pieceVariant);\n  newPiece.x = x;\n  newPiece.y = y;\n  newPiece.draw();\n  if (newPiece.isCollition(x, y, pieceVariant)) return null;\n  return newPiece;\n}\n\nconst GameCanvas = props => {\n  const canvasRef = useRef(null);\n  const [context, setContext] = useState(null);\n  const [grid, setGrid] = useState(null);\n  const [currentPiece, setCurrentPiece] = useState(null);\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderCtx = canvasRef.current.getContext(\"2d\");\n\n      if (renderCtx) {\n        setContext(renderCtx);\n      }\n    }\n  }, [context]);\n  useEffect(() => {\n    if (context) {\n      if (!grid) {\n        let gr = new CanvasGrid(context);\n        gr.init();\n        setGrid(gr);\n      } else {\n        console.log(\"grid already exist\");\n\n        if (!currentPiece) {\n          let piece = newPiece(context, grid);\n          piece.draw();\n          setCurrentPiece(piece);\n        } else {\n          console.log(\"current piece already set: \", currentPiece);\n        }\n        /**\n         * this should be where the drawing magic happens\n         */\n\n      }\n    }\n\n    return () => {\n      console.log(\"this is where the cleanup stuff happens\");\n    };\n  }, [context, grid, currentPiece]);\n  useEffect(() => {\n    const handleKeyPress = ({\n      key\n    }) => controls(key, currentPiece, grid, context);\n\n    if (currentPiece) {\n      document.addEventListener(\"keydown\", handleKeyPress);\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyPress);\n    };\n  }, [currentPiece, grid, context]);\n  const [seconds, setSeconds] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(seconds => seconds + 1);\n      if (currentPiece) if (!currentPiece.moveDown()) {\n        currentPiece.lock();\n        grid.removeFilledLines();\n        let np = newPiece(context, grid);\n        if (!np) props.setGameOver(true);\n        setCurrentPiece(np);\n        setSeconds(0);\n        console.log(\"lock current piece and request for the next piece\");\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [currentPiece, context, grid, props]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      textAlign: \"center\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 4\n    }\n  }, seconds, \" seconds since mount\"), /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    ref: canvasRef,\n    width: config.COLS * config.BLOCK,\n    height: config.ROWS * config.BLOCK,\n    style: {\n      border: \"2px solid #000\",\n      marginTop: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 4\n    }\n  }));\n};\n\nexport default GameCanvas;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx"],"names":["React","useEffect","useState","useRef","pieces","pieceStartPosition","config","CanvasGrid","Piece","controls","key","piece","grid","context","rotate","moveLeft","moveRight","moveDown","lock","penalty","newPiece","pieceNum","Math","floor","random","length","pieceVariant","console","log","active","y","x","draw","isCollition","GameCanvas","props","canvasRef","setContext","setGrid","currentPiece","setCurrentPiece","current","renderCtx","getContext","gr","init","handleKeyPress","document","addEventListener","removeEventListener","seconds","setSeconds","interval","setInterval","removeFilledLines","np","setGameOver","clearInterval","textAlign","COLS","BLOCK","ROWS","border","marginTop"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useRef } from \"react\"\nimport { pieces, pieceStartPosition } from \"../misc/pieces\"\nimport { config } from \"../misc/canvasConfig\"\nimport CanvasGrid from \"../misc/canvasGrid\"\nimport Piece from \"../misc/Piece\"\n\nfunction controls(key, piece, grid, context) {\n\tif (key === \"ArrowUp\") piece.rotate()\n\tif (key === \"ArrowLeft\") piece.moveLeft()\n\tif (key === \"ArrowRight\") piece.moveRight()\n\tif (key === \"ArrowDown\") piece.moveDown()\n\tif (key === \"l\") piece.lock()\n\tif (key === \"p\") grid.penalty(piece)\n\tif (key === \"n\") newPiece(context, grid)\n}\n\nfunction newPiece(context, grid) {\n\tif (!context || !grid) return null\n\n\tlet pieceNum = Math.floor(Math.random() * pieces.length)\n\tlet pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length)\n\tconsole.log(pieceNum, pieceVariant)\n\tlet newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1])\n\n\tnewPiece.active = pieceVariant\n\tlet [y, x] = pieceStartPosition(pieceNum, pieceVariant)\n\tnewPiece.x = x\n\tnewPiece.y = y\n\tnewPiece.draw()\n\tif (newPiece.isCollition(x, y, pieceVariant)) return null\n\treturn newPiece\n}\n\nconst GameCanvas = (props) => {\n\tconst canvasRef = useRef(null)\n\tconst [context, setContext] = useState(null)\n\tconst [grid, setGrid] = useState(null)\n\tconst [currentPiece, setCurrentPiece] = useState(null)\n\n\tuseEffect(() => {\n\t\tif (canvasRef.current) {\n\t\t\tconst renderCtx = canvasRef.current.getContext(\"2d\")\n\n\t\t\tif (renderCtx) {\n\t\t\t\tsetContext(renderCtx)\n\t\t\t}\n\t\t}\n\t}, [context])\n\n\tuseEffect(() => {\n\t\tif (context) {\n\t\t\tif (!grid) {\n\t\t\t\tlet gr = new CanvasGrid(context)\n\t\t\t\tgr.init()\n\t\t\t\tsetGrid(gr)\n\t\t\t} else {\n\t\t\t\tconsole.log(\"grid already exist\")\n\n\t\t\t\tif (!currentPiece) {\n\t\t\t\t\tlet piece = newPiece(context, grid)\n\t\t\t\t\tpiece.draw()\n\t\t\t\t\tsetCurrentPiece(piece)\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"current piece already set: \", currentPiece)\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * this should be where the drawing magic happens\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\tconsole.log(\"this is where the cleanup stuff happens\")\n\t\t}\n\t}, [context, grid, currentPiece])\n\n\tuseEffect(() => {\n\t\tconst handleKeyPress = ({ key }) => controls(key, currentPiece, grid, context)\n\t\tif (currentPiece) {\n\t\t\tdocument.addEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t}, [currentPiece, grid, context])\n\n\tconst [seconds, setSeconds] = useState(0)\n\n\tuseEffect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tsetSeconds((seconds) => seconds + 1)\n\t\t\tif (currentPiece)\n\t\t\t\tif (!currentPiece.moveDown()) {\n\t\t\t\t\tcurrentPiece.lock()\n\t\t\t\t\tgrid.removeFilledLines()\n\t\t\t\t\tlet np = newPiece(context, grid)\n\t\t\t\t\tif (!np) props.setGameOver(true)\n\t\t\t\t\tsetCurrentPiece(np)\n\t\t\t\t\tsetSeconds(0)\n\t\t\t\t\tconsole.log(\"lock current piece and request for the next piece\")\n\t\t\t\t}\n\t\t}, 1000)\n\t\treturn () => clearInterval(interval)\n\t}, [currentPiece, context, grid, props])\n\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\ttextAlign: \"center\",\n\t\t\t}}>\n\t\t\t<h3>{seconds} seconds since mount</h3>\n\t\t\t<canvas\n\t\t\t\tid=\"canvas\"\n\t\t\t\tref={canvasRef}\n\t\t\t\twidth={config.COLS * config.BLOCK}\n\t\t\t\theight={config.ROWS * config.BLOCK}\n\t\t\t\tstyle={{\n\t\t\t\t\tborder: \"2px solid #000\",\n\t\t\t\t\tmarginTop: 10,\n\t\t\t\t}}></canvas>\n\t\t</div>\n\t)\n}\n\nexport default GameCanvas\n"]},"metadata":{},"sourceType":"module"}