{"ast":null,"code":"var _jsxFileName = \"/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { pieces, pieceStartPosition } from \"../misc/pieces\";\nimport { config } from \"../misc/canvasConfig\";\n/****\n * Canvas drawing functions\n */\n\nconst drawBlock = (context, x, y, colour = config.EMPTY_BG, strokeColour = config.BORDER) => {\n  context.fillStyle = colour;\n  context.fillRect(x * config.BLOCK, y * config.BLOCK, config.BLOCK, config.BLOCK);\n  context.strokeStyle = strokeColour;\n  context.strokeRect(x * config.BLOCK, y * config.BLOCK, config.BLOCK, config.BLOCK);\n};\n/***\n * Tetramino Class\n */\n\n\nfunction Piece(context, grid, piece, colour) {\n  this.piece = piece;\n  this.colour = colour;\n  this.active = 0;\n  this.x = 0;\n  this.y = 0;\n  this.context = context;\n  this.grid = grid;\n\n  this.draw = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, this.colour);\n      }\n    }\n  };\n\n  this.clear = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, EMPTY_BG);\n      }\n    }\n  };\n\n  this.lock = () => {\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) grid.coords[this.y + row][this.x + col] = this.colour;\n      }\n    }\n  };\n\n  this.rotate = () => {\n    if (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 2;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    }\n  };\n\n  this.moveLeft = () => {\n    if (!this.isCollition(this.x - 1)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.draw();\n    }\n  };\n\n  this.moveRight = () => {\n    if (!this.isCollition(this.x + 1)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.draw();\n    }\n  };\n\n  this.moveDown = () => {\n    if (!this.isCollition(this.x, this.y + 1)) {\n      this.clear();\n      this.y = this.y + 1;\n      this.draw();\n      return true;\n    }\n\n    return false;\n  };\n\n  this.isCollition = (newX = this.x, newY = this.y, newState = this.active) => {\n    for (let row = 0; row < this.piece[newState].length; row++) {\n      for (let col = 0; col < this.piece[newState][row].length; col++) {\n        if (this.piece[newState][row][col]) {\n          if (newX + col < 0 || newX + col >= this.colums || newY + row >= this.rows) {\n            console.log(\"collision\");\n            return true;\n          }\n\n          if (this.grid.coords[newY + row][newX + col] !== config.EMPTY_BG) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n}\n/**\n * Grid class\n */\n\n\nfunction Grid(context, colums = config.COLS, rows = config.ROWS, backgroundColour = config.EMPTY_BG) {\n  this.colums = colums;\n  this.rows = rows;\n  this.colour = backgroundColour;\n  this.coords = [];\n\n  this.init = () => {\n    for (let row = 0; row < this.rows; row++) {\n      this.coords[row] = [];\n\n      for (let col = 0; col < this.colums; col++) {\n        this.coords[row][col] = config.EMPTY_BG;\n      }\n    }\n\n    this.draw();\n  };\n\n  this.draw = () => {\n    let r = 0;\n    let c = 0;\n\n    while (this.coords[r]) {\n      c = 0;\n\n      while (this.coords[r][c]) {\n        drawBlock(context, c, r, this.coords[r][c]);\n        c++;\n      }\n\n      r++;\n    }\n  };\n\n  this.penalty = currentPiece => {\n    let y = 0;\n\n    while (this.coords[y + 1]) {\n      this.coords[y] = this.coords[y + 1];\n      y++;\n    }\n\n    this.coords[y] = [];\n\n    for (let c = 0; c < config.COLS; c++) {\n      this.coords[y][c] = config.PENALTY_BG;\n    }\n\n    this.draw();\n    if (currentPiece.y - 1 >= 0) currentPiece.y -= 1;\n    currentPiece.draw();\n  };\n\n  this.removeFilledLines = () => {\n    for (let y = this.coords.length - 1; y > 0; y--) {\n      let lineFull = true;\n\n      for (let x = 0; x < this.coords[y].length; x++) {\n        if (this.coords[y][x] === config.EMPTY_BG || this.coords[y][x] === config.PENALTY_BG) {\n          lineFull = false;\n          break;\n        }\n      }\n\n      if (lineFull) {\n        for (let z = y; z > 0; z--) {\n          this.coords[z] = this.coords[z - 1];\n        }\n\n        this.coords[0] = [];\n\n        for (let i = 0; i < this.colums; i++) {\n          this.coords[0][i] = config.EMPTY_BG;\n        }\n\n        y--;\n      }\n    }\n\n    this.draw();\n  };\n}\n\nfunction controls(key, piece, grid, context) {\n  if (key === \"ArrowUp\") piece.rotate();\n  if (key === \"ArrowLeft\") piece.moveLeft();\n  if (key === \"ArrowRight\") piece.moveRight();\n  if (key === \"ArrowDown\") piece.moveDown();\n  if (key === \"l\") piece.lock();\n  if (key === \"p\") grid.penalty(piece);\n  if (key === \"n\") newPiece(context, grid);\n}\n\nfunction newPiece(context, grid) {\n  if (!context || !grid) return null;\n  let pieceNum = Math.floor(Math.random() * pieces.length);\n  let pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length);\n  console.log(pieceNum, pieceVariant);\n  let newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1]);\n  newPiece.active = pieceVariant;\n  let [y, x] = pieceStartPosition(pieceNum, pieceVariant);\n  newPiece.x = x;\n  newPiece.y = y;\n  newPiece.draw();\n  if (newPiece.isCollition(x, y, pieceVariant)) return null;\n  return newPiece;\n}\n\nconst GameCanvas = props => {\n  const canvasRef = useRef(null);\n  const [context, setContext] = useState(null);\n  const [grid, setGrid] = useState(null);\n  const [currentPiece, setCurrentPiece] = useState(null);\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderCtx = canvasRef.current.getContext(\"2d\");\n\n      if (renderCtx) {\n        setContext(renderCtx);\n      }\n    }\n  }, [context]);\n  useEffect(() => {\n    if (context) {\n      if (!grid) {\n        let gr = new Grid(context);\n        gr.init();\n        setGrid(gr);\n      } else {\n        console.log(\"grid already exist\");\n\n        if (!currentPiece) {\n          let piece = newPiece(context, grid);\n          piece.draw();\n          setCurrentPiece(piece);\n        } else {\n          console.log(\"current piece already set: \", currentPiece);\n        }\n        /**\n         * this should be where the drawing magic happens\n         */\n\n      }\n    }\n\n    return () => {\n      console.log(\"this is where the cleanup stuff happens\");\n    };\n  }, [context, grid, currentPiece]);\n  useEffect(() => {\n    const handleKeyPress = ({\n      key\n    }) => controls(key, currentPiece, grid, context);\n\n    if (currentPiece) {\n      document.addEventListener(\"keydown\", handleKeyPress);\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyPress);\n    };\n  }, [currentPiece, grid, context]);\n  const [seconds, setSeconds] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(seconds => seconds + 1);\n      if (currentPiece) if (!currentPiece.moveDown()) {\n        currentPiece.lock();\n        grid.removeFilledLines();\n        let np = newPiece(context, grid);\n        if (!np) props.setGameOver(true);\n        setCurrentPiece(np);\n        setSeconds(0);\n        console.log(\"lock current piece and request for the next piece\");\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [currentPiece, context, grid, props]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      textAlign: \"center\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 4\n    }\n  }, seconds, \" seconds since mount\"), /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    ref: canvasRef,\n    width: config.COLS * config.BLOCK,\n    height: config.ROWS * config.BLOCK,\n    style: {\n      border: \"2px solid #000\",\n      marginTop: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 302,\n      columnNumber: 4\n    }\n  }));\n};\n\nexport default GameCanvas;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx"],"names":["React","useEffect","useState","useRef","pieces","pieceStartPosition","config","drawBlock","context","x","y","colour","EMPTY_BG","strokeColour","BORDER","fillStyle","fillRect","BLOCK","strokeStyle","strokeRect","Piece","grid","piece","active","draw","row","length","col","clear","lock","coords","rotate","isCollition","moveLeft","moveRight","moveDown","newX","newY","newState","colums","rows","console","log","Grid","COLS","ROWS","backgroundColour","init","r","c","penalty","currentPiece","PENALTY_BG","removeFilledLines","lineFull","z","i","controls","key","newPiece","pieceNum","Math","floor","random","pieceVariant","GameCanvas","props","canvasRef","setContext","setGrid","setCurrentPiece","current","renderCtx","getContext","gr","handleKeyPress","document","addEventListener","removeEventListener","seconds","setSeconds","interval","setInterval","np","setGameOver","clearInterval","textAlign","border","marginTop"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useRef } from \"react\"\nimport { pieces, pieceStartPosition } from \"../misc/pieces\"\nimport { config } from \"../misc/canvasConfig\"\n\n/****\n * Canvas drawing functions\n */\nconst drawBlock = (context, x, y, colour = config.EMPTY_BG, strokeColour = config.BORDER) => {\n\tcontext.fillStyle = colour\n\tcontext.fillRect(x * config.BLOCK, y * config.BLOCK, config.BLOCK, config.BLOCK)\n\tcontext.strokeStyle = strokeColour\n\tcontext.strokeRect(x * config.BLOCK, y * config.BLOCK, config.BLOCK, config.BLOCK)\n}\n\n/***\n * Tetramino Class\n */\n\nfunction Piece(context, grid, piece, colour) {\n\tthis.piece = piece\n\tthis.colour = colour\n\tthis.active = 0\n\tthis.x = 0\n\tthis.y = 0\n\tthis.context = context\n\tthis.grid = grid\n\n\tthis.draw = (active = this.active) => {\n\t\tthis.active = active\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, this.colour)\n\t\t\t}\n\t\t}\n\t}\n\tthis.clear = (active = this.active) => {\n\t\tthis.active = active\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, EMPTY_BG)\n\t\t\t}\n\t\t}\n\t}\n\tthis.lock = () => {\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[this.active][row].length; col++) {\n\t\t\t\tif (this.piece[this.active][row][col]) grid.coords[this.y + row][this.x + col] = this.colour\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.rotate = () => {\n\t\tif (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x + 1\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 1\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t} else if (!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 2\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveLeft = () => {\n\t\tif (!this.isCollition(this.x - 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x - 1\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveRight = () => {\n\t\tif (!this.isCollition(this.x + 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.x = this.x + 1\n\t\t\tthis.draw()\n\t\t}\n\t}\n\n\tthis.moveDown = () => {\n\t\tif (!this.isCollition(this.x, this.y + 1)) {\n\t\t\tthis.clear()\n\t\t\tthis.y = this.y + 1\n\t\t\tthis.draw()\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tthis.isCollition = (newX = this.x, newY = this.y, newState = this.active) => {\n\t\tfor (let row = 0; row < this.piece[newState].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[newState][row].length; col++) {\n\t\t\t\tif (this.piece[newState][row][col]) {\n\t\t\t\t\tif (newX + col < 0 || newX + col >= this.colums || newY + row >= this.rows) {\n\t\t\t\t\t\tconsole.log(\"collision\")\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tif (this.grid.coords[newY + row][newX + col] !== config.EMPTY_BG) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n}\n\n/**\n * Grid class\n */\n\nfunction Grid(context, colums = config.COLS, rows = config.ROWS, backgroundColour = config.EMPTY_BG) {\n\tthis.colums = colums\n\tthis.rows = rows\n\tthis.colour = backgroundColour\n\tthis.coords = []\n\n\tthis.init = () => {\n\t\tfor (let row = 0; row < this.rows; row++) {\n\t\t\tthis.coords[row] = []\n\t\t\tfor (let col = 0; col < this.colums; col++) {\n\t\t\t\tthis.coords[row][col] = config.EMPTY_BG\n\t\t\t}\n\t\t}\n\t\tthis.draw()\n\t}\n\n\tthis.draw = () => {\n\t\tlet r = 0\n\t\tlet c = 0\n\t\twhile (this.coords[r]) {\n\t\t\tc = 0\n\t\t\twhile (this.coords[r][c]) {\n\t\t\t\tdrawBlock(context, c, r, this.coords[r][c])\n\t\t\t\tc++\n\t\t\t}\n\t\t\tr++\n\t\t}\n\t}\n\n\tthis.penalty = (currentPiece) => {\n\t\tlet y = 0\n\t\twhile (this.coords[y + 1]) {\n\t\t\tthis.coords[y] = this.coords[y + 1]\n\t\t\ty++\n\t\t}\n\t\tthis.coords[y] = []\n\t\tfor (let c = 0; c < config.COLS; c++) {\n\t\t\tthis.coords[y][c] = config.PENALTY_BG\n\t\t}\n\t\tthis.draw()\n\n\t\tif (currentPiece.y - 1 >= 0) currentPiece.y -= 1\n\t\tcurrentPiece.draw()\n\t}\n\n\tthis.removeFilledLines = () => {\n\t\tfor (let y = this.coords.length - 1; y > 0; y--) {\n\t\t\tlet lineFull = true\n\t\t\tfor (let x = 0; x < this.coords[y].length; x++) {\n\t\t\t\tif (this.coords[y][x] === config.EMPTY_BG || this.coords[y][x] === config.PENALTY_BG) {\n\t\t\t\t\tlineFull = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineFull) {\n\t\t\t\tfor (let z = y; z > 0; z--) {\n\t\t\t\t\tthis.coords[z] = this.coords[z - 1]\n\t\t\t\t}\n\t\t\t\tthis.coords[0] = []\n\t\t\t\tfor (let i = 0; i < this.colums; i++) {\n\t\t\t\t\tthis.coords[0][i] = config.EMPTY_BG\n\t\t\t\t}\n\t\t\t\ty--\n\t\t\t}\n\t\t}\n\t\tthis.draw()\n\t}\n}\n\nfunction controls(key, piece, grid, context) {\n\tif (key === \"ArrowUp\") piece.rotate()\n\tif (key === \"ArrowLeft\") piece.moveLeft()\n\tif (key === \"ArrowRight\") piece.moveRight()\n\tif (key === \"ArrowDown\") piece.moveDown()\n\tif (key === \"l\") piece.lock()\n\tif (key === \"p\") grid.penalty(piece)\n\tif (key === \"n\") newPiece(context, grid)\n}\n\nfunction newPiece(context, grid) {\n\tif (!context || !grid) return null\n\n\tlet pieceNum = Math.floor(Math.random() * pieces.length)\n\tlet pieceVariant = Math.floor(Math.random() * pieces[pieceNum][0].length)\n\tconsole.log(pieceNum, pieceVariant)\n\tlet newPiece = new Piece(context, grid, pieces[pieceNum][0], pieces[pieceNum][1])\n\n\tnewPiece.active = pieceVariant\n\tlet [y, x] = pieceStartPosition(pieceNum, pieceVariant)\n\tnewPiece.x = x\n\tnewPiece.y = y\n\tnewPiece.draw()\n\tif (newPiece.isCollition(x, y, pieceVariant)) return null\n\treturn newPiece\n}\n\nconst GameCanvas = (props) => {\n\tconst canvasRef = useRef(null)\n\tconst [context, setContext] = useState(null)\n\tconst [grid, setGrid] = useState(null)\n\tconst [currentPiece, setCurrentPiece] = useState(null)\n\n\tuseEffect(() => {\n\t\tif (canvasRef.current) {\n\t\t\tconst renderCtx = canvasRef.current.getContext(\"2d\")\n\n\t\t\tif (renderCtx) {\n\t\t\t\tsetContext(renderCtx)\n\t\t\t}\n\t\t}\n\t}, [context])\n\n\tuseEffect(() => {\n\t\tif (context) {\n\t\t\tif (!grid) {\n\t\t\t\tlet gr = new Grid(context)\n\t\t\t\tgr.init()\n\t\t\t\tsetGrid(gr)\n\t\t\t} else {\n\t\t\t\tconsole.log(\"grid already exist\")\n\n\t\t\t\tif (!currentPiece) {\n\t\t\t\t\tlet piece = newPiece(context, grid)\n\t\t\t\t\tpiece.draw()\n\t\t\t\t\tsetCurrentPiece(piece)\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"current piece already set: \", currentPiece)\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * this should be where the drawing magic happens\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\tconsole.log(\"this is where the cleanup stuff happens\")\n\t\t}\n\t}, [context, grid, currentPiece])\n\n\tuseEffect(() => {\n\t\tconst handleKeyPress = ({ key }) => controls(key, currentPiece, grid, context)\n\t\tif (currentPiece) {\n\t\t\tdocument.addEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"keydown\", handleKeyPress)\n\t\t}\n\t}, [currentPiece, grid, context])\n\n\tconst [seconds, setSeconds] = useState(0)\n\n\tuseEffect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tsetSeconds((seconds) => seconds + 1)\n\t\t\tif (currentPiece)\n\t\t\t\tif (!currentPiece.moveDown()) {\n\t\t\t\t\tcurrentPiece.lock()\n\t\t\t\t\tgrid.removeFilledLines()\n\t\t\t\t\tlet np = newPiece(context, grid)\n\t\t\t\t\tif (!np) props.setGameOver(true)\n\t\t\t\t\tsetCurrentPiece(np)\n\t\t\t\t\tsetSeconds(0)\n\t\t\t\t\tconsole.log(\"lock current piece and request for the next piece\")\n\t\t\t\t}\n\t\t}, 1000)\n\t\treturn () => clearInterval(interval)\n\t}, [currentPiece, context, grid, props])\n\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\ttextAlign: \"center\",\n\t\t\t}}>\n\t\t\t<h3>{seconds} seconds since mount</h3>\n\t\t\t<canvas\n\t\t\t\tid=\"canvas\"\n\t\t\t\tref={canvasRef}\n\t\t\t\twidth={config.COLS * config.BLOCK}\n\t\t\t\theight={config.ROWS * config.BLOCK}\n\t\t\t\tstyle={{\n\t\t\t\t\tborder: \"2px solid #000\",\n\t\t\t\t\tmarginTop: 10,\n\t\t\t\t}}></canvas>\n\t\t</div>\n\t)\n}\n\nexport default GameCanvas\n"]},"metadata":{},"sourceType":"module"}