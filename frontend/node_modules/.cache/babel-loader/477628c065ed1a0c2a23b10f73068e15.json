{"ast":null,"code":"var _jsxFileName = \"/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { pieces } from \"../misc/pieces\";\n/**********************************\\\n * canvas config data\n\\**********************************/\n\nconst ROWS = 20;\nconst COLS = 10;\nconst EMPTY_BG = \"#765\";\nconst BORDER = \"adf\";\nconst BLOCK = 30;\n/****\n * Canvas drawing functions\n */\n\nconst drawBlock = (context, x, y, colour = EMPTY_BG, strokeColour = BORDER) => {\n  context.fillStyle = colour;\n  context.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);\n  context.strokeStyle = strokeColour;\n  context.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);\n};\n/***\n * Tetramino Class\n */\n\n\nfunction Piece(context, grid, piece, colour) {\n  this.piece = piece;\n  this.colour = colour;\n  this.active = 0;\n  this.x = 0;\n  this.y = 0;\n  this.context = context;\n\n  this.draw = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, this.colour);\n      }\n    }\n  };\n\n  this.clear = (active = this.active) => {\n    this.active = active;\n\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) drawBlock(this.context, this.x + col, this.y + row, EMPTY_BG);\n      }\n    }\n  };\n\n  this.lock = () => {\n    for (let row = 0; row < this.piece[this.active].length; row++) {\n      for (let col = 0; col < this.piece[this.active][row].length; col++) {\n        if (this.piece[this.active][row][col]) grid.coords[this.y + row][this.x + col] = this.colour;\n      }\n    }\n  };\n\n  this.rotate = () => {\n    if (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    } else if (!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)) {\n      this.clear();\n      this.x = this.x - 2;\n      this.active = (1 + this.active) % this.piece.length;\n      this.draw();\n    }\n  };\n\n  this.moveLeft = () => {\n    if (!this.isCollition(this.x - 1)) {\n      this.clear();\n      this.x = this.x - 1;\n      this.draw();\n    }\n  };\n\n  this.moveRight = () => {\n    if (!this.isCollition(this.x + 1)) {\n      this.clear();\n      this.x = this.x + 1;\n      this.draw();\n    }\n  };\n\n  this.moveDown = () => {\n    if (!this.isCollition(this.x, this.y + 1)) {\n      this.clear();\n      this.y = this.y + 1;\n      this.draw();\n    }\n  };\n\n  this.isCollition = (newX = this.x, newY = this.y, newState = this.active) => {\n    for (let row = 0; row < this.piece[newState].length; row++) {\n      for (let col = 0; col < this.piece[newState][row].length; col++) {\n        if (this.piece[newState][row][col]) {\n          if (newX + col < 0 || newX + col >= COLS || newY + row >= ROWS) {\n            console.log(\"collision\");\n            return true;\n          }\n\n          if (grid.coords[newY + row][newX + col] !== EMPTY_BG) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n}\n/**\n * Grid class\n */\n\n\nfunction Grid(context, colums = COLS, rows = ROWS, backgroundColour = EMPTY_BG) {\n  this.colums = colums;\n  this.rows = rows;\n  this.colour = backgroundColour;\n  this.coords = [];\n\n  this.init = () => {\n    for (let row = 0; row < this.rows; row++) {\n      this.coords[row] = [];\n\n      for (let col = 0; col < this.colums; col++) {\n        this.coords[row][col] = EMPTY_BG;\n      }\n    }\n\n    this.draw();\n  };\n\n  this.draw = () => {\n    let r = 0;\n    let c = 0;\n\n    while (this.coords[r]) {\n      console.log(\"row number \", r, \"coord :\", {\n        coords: this.coords[r]\n      });\n      c = 0;\n\n      while (this.coords[r][c]) {\n        console.log(\"col number \", c, \"coord :\", {\n          coords: this.coords[r][c]\n        });\n        drawBlock(context, c, r, this.coords[r][c]);\n        c++;\n      }\n\n      r++;\n    }\n  };\n}\n\nconst GameCanvas = () => {\n  const canvasRef = useRef(null);\n  const [context, setContext] = useState(null);\n  const [grid, setGrid] = useState(null);\n  const [currentPiece, setCurrentPiece] = useState(null);\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderCtx = canvasRef.current.getContext(\"2d\");\n\n      if (renderCtx) {\n        setContext(renderCtx);\n      }\n    }\n  }, [context]);\n  useEffect(() => {\n    if (context) {\n      if (!grid) {\n        let gr = new Grid(context);\n        gr.init();\n        setGrid(gr);\n        console.log(gr);\n      } else {\n        console.log(\"grid already exist\");\n      }\n\n      if (!currentPiece) {\n        let piece = new Piece(context, grid);\n      }\n      /**\n       * this should be where the drawing magic happens\n       */\n\n    }\n\n    return () => {\n      console.log(\"this is where the cleanup stuff happens\");\n    };\n  }, [context, grid]);\n\n  const penalty = () => {\n    let y = 0;\n\n    while (grid.coords[y + 1]) {\n      console.log(\"is it shifting?\");\n      grid.coords[y] = grid.coords[y + 1];\n      y++;\n    }\n\n    grid.coords[y] = [];\n\n    for (let c = 0; c < COLS; c++) {\n      grid.coords[y][c] = \"red\";\n    }\n\n    grid.draw();\n  };\n\n  function Controls({\n    key\n  }) {\n    console.log(key);\n    if (key === \"ArrowUp\") currentPiece.rotate();\n    if (key === \"ArrowLeft\") currentPiece.moveLeft();\n    if (key === \"ArrowRight\") currentPiece.moveRight();\n    if (key === \"ArrowDown\") currentPiece.moveDown();\n    if (key === \"l\") currentPiece.lock();\n    if (key === \"p\") penalty();\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      textAlign: \"center\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    ref: canvasRef,\n    width: COLS * BLOCK,\n    height: ROWS * BLOCK,\n    style: {\n      border: \"2px solid #000\",\n      marginTop: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 4\n    }\n  }));\n};\n\nexport default GameCanvas;","map":{"version":3,"sources":["/home/mosima/Desktop/red_tetris/frontend/src/components/GameCanvas.jsx"],"names":["React","useEffect","useState","useRef","pieces","ROWS","COLS","EMPTY_BG","BORDER","BLOCK","drawBlock","context","x","y","colour","strokeColour","fillStyle","fillRect","strokeStyle","strokeRect","Piece","grid","piece","active","draw","row","length","col","clear","lock","coords","rotate","isCollition","moveLeft","moveRight","moveDown","newX","newY","newState","console","log","Grid","colums","rows","backgroundColour","init","r","c","GameCanvas","canvasRef","setContext","setGrid","currentPiece","setCurrentPiece","current","renderCtx","getContext","gr","penalty","Controls","key","textAlign","border","marginTop"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useRef } from \"react\";\nimport { pieces } from \"../misc/pieces\";\n\n/**********************************\\\n * canvas config data\n\\**********************************/\nconst ROWS = 20;\nconst COLS = 10;\nconst EMPTY_BG = \"#765\";\nconst BORDER = \"adf\";\nconst BLOCK = 30;\n\n/****\n * Canvas drawing functions\n */\nconst drawBlock = (context, x, y, colour = EMPTY_BG, strokeColour = BORDER) => {\n\tcontext.fillStyle = colour;\n\tcontext.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);\n\tcontext.strokeStyle = strokeColour;\n\tcontext.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);\n};\n\n/***\n * Tetramino Class\n */\n\nfunction Piece(context, grid, piece, colour) {\n\tthis.piece = piece;\n\tthis.colour = colour;\n\tthis.active = 0;\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.context = context;\n\n\tthis.draw = (active = this.active) => {\n\t\tthis.active = active;\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (\n\t\t\t\tlet col = 0;\n\t\t\t\tcol < this.piece[this.active][row].length;\n\t\t\t\tcol++\n\t\t\t) {\n\t\t\t\tif (this.piece[this.active][row][col])\n\t\t\t\t\tdrawBlock(\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tthis.x + col,\n\t\t\t\t\t\tthis.y + row,\n\t\t\t\t\t\tthis.colour\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\tthis.clear = (active = this.active) => {\n\t\tthis.active = active;\n\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (\n\t\t\t\tlet col = 0;\n\t\t\t\tcol < this.piece[this.active][row].length;\n\t\t\t\tcol++\n\t\t\t) {\n\t\t\t\tif (this.piece[this.active][row][col])\n\t\t\t\t\tdrawBlock(\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tthis.x + col,\n\t\t\t\t\t\tthis.y + row,\n\t\t\t\t\t\tEMPTY_BG\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\tthis.lock = () => {\n\t\tfor (let row = 0; row < this.piece[this.active].length; row++) {\n\t\t\tfor (\n\t\t\t\tlet col = 0;\n\t\t\t\tcol < this.piece[this.active][row].length;\n\t\t\t\tcol++\n\t\t\t) {\n\t\t\t\tif (this.piece[this.active][row][col])\n\t\t\t\t\tgrid.coords[this.y + row][this.x + col] = this.colour;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.rotate = () => {\n\t\tif (!this.isCollition(this.x, this.y, (this.active + 1) % 4)) {\n\t\t\tthis.clear();\n\t\t\tthis.active = (1 + this.active) % this.piece.length;\n\t\t\tthis.draw();\n\t\t} else if (\n\t\t\t!this.isCollition(this.x + 1, this.y, (this.active + 1) % 4)\n\t\t) {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.x + 1;\n\t\t\tthis.active = (1 + this.active) % this.piece.length;\n\t\t\tthis.draw();\n\t\t} else if (\n\t\t\t!this.isCollition(this.x - 1, this.y, (this.active + 1) % 4)\n\t\t) {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.x - 1;\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length;\n\t\t\tthis.draw();\n\t\t} else if (\n\t\t\t!this.isCollition(this.x - 2, this.y, (this.active + 1) % 4)\n\t\t) {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.x - 2;\n\n\t\t\tthis.active = (1 + this.active) % this.piece.length;\n\t\t\tthis.draw();\n\t\t}\n\t};\n\n\tthis.moveLeft = () => {\n\t\tif (!this.isCollition(this.x - 1)) {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.x - 1;\n\t\t\tthis.draw();\n\t\t}\n\t};\n\n\tthis.moveRight = () => {\n\t\tif (!this.isCollition(this.x + 1)) {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.x + 1;\n\t\t\tthis.draw();\n\t\t}\n\t};\n\n\tthis.moveDown = () => {\n\t\tif (!this.isCollition(this.x, this.y + 1)) {\n\t\t\tthis.clear();\n\t\t\tthis.y = this.y + 1;\n\t\t\tthis.draw();\n\t\t}\n\t};\n\n\tthis.isCollition = (\n\t\tnewX = this.x,\n\t\tnewY = this.y,\n\t\tnewState = this.active\n\t) => {\n\t\tfor (let row = 0; row < this.piece[newState].length; row++) {\n\t\t\tfor (let col = 0; col < this.piece[newState][row].length; col++) {\n\t\t\t\tif (this.piece[newState][row][col]) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tnewX + col < 0 ||\n\t\t\t\t\t\tnewX + col >= COLS ||\n\t\t\t\t\t\tnewY + row >= ROWS\n\t\t\t\t\t) {\n\t\t\t\t\t\tconsole.log(\"collision\");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (grid.coords[newY + row][newX + col] !== EMPTY_BG) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n}\n\n/**\n * Grid class\n */\n\nfunction Grid(\n\tcontext,\n\tcolums = COLS,\n\trows = ROWS,\n\tbackgroundColour = EMPTY_BG\n) {\n\tthis.colums = colums;\n\tthis.rows = rows;\n\tthis.colour = backgroundColour;\n\tthis.coords = [];\n\n\tthis.init = () => {\n\t\tfor (let row = 0; row < this.rows; row++) {\n\t\t\tthis.coords[row] = [];\n\t\t\tfor (let col = 0; col < this.colums; col++) {\n\t\t\t\tthis.coords[row][col] = EMPTY_BG;\n\t\t\t}\n\t\t}\n\t\tthis.draw();\n\t};\n\tthis.draw = () => {\n\t\tlet r = 0;\n\t\tlet c = 0;\n\t\twhile (this.coords[r]) {\n\t\t\tconsole.log(\"row number \", r, \"coord :\", {\n\t\t\t\tcoords: this.coords[r],\n\t\t\t});\n\t\t\tc = 0;\n\t\t\twhile (this.coords[r][c]) {\n\t\t\t\tconsole.log(\"col number \", c, \"coord :\", {\n\t\t\t\t\tcoords: this.coords[r][c],\n\t\t\t\t});\n\n\t\t\t\tdrawBlock(context, c, r, this.coords[r][c]);\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t};\n}\n\nconst GameCanvas = () => {\n\tconst canvasRef = useRef(null);\n\tconst [context, setContext] = useState(null);\n\tconst [grid, setGrid] = useState(null);\n\tconst [currentPiece, setCurrentPiece] = useState(null);\n\n\tuseEffect(() => {\n\t\tif (canvasRef.current) {\n\t\t\tconst renderCtx = canvasRef.current.getContext(\"2d\");\n\n\t\t\tif (renderCtx) {\n\t\t\t\tsetContext(renderCtx);\n\t\t\t}\n\t\t}\n\t}, [context]);\n\n\tuseEffect(() => {\n\t\tif (context) {\n\t\t\tif (!grid) {\n\t\t\t\tlet gr = new Grid(context);\n\t\t\t\tgr.init();\n\t\t\t\tsetGrid(gr);\n\t\t\t\tconsole.log(gr);\n\t\t\t} else {\n\t\t\t\tconsole.log(\"grid already exist\");\n\t\t\t}\n\t\t\tif (!currentPiece) {\n\t\t\t\tlet piece = new Piece(context, grid);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * this should be where the drawing magic happens\n\t\t\t */\n\t\t}\n\t\treturn () => {\n\t\t\tconsole.log(\"this is where the cleanup stuff happens\");\n\t\t};\n\t}, [context, grid]);\n\n\tconst penalty = () => {\n\t\tlet y = 0;\n\t\twhile (grid.coords[y + 1]) {\n\t\t\tconsole.log(\"is it shifting?\");\n\t\t\tgrid.coords[y] = grid.coords[y + 1];\n\t\t\ty++;\n\t\t}\n\t\tgrid.coords[y] = [];\n\t\tfor (let c = 0; c < COLS; c++) {\n\t\t\tgrid.coords[y][c] = \"red\";\n\t\t}\n\t\tgrid.draw();\n\t};\n\n\tfunction Controls({ key }) {\n\t\tconsole.log(key);\n\t\tif (key === \"ArrowUp\") currentPiece.rotate();\n\t\tif (key === \"ArrowLeft\") currentPiece.moveLeft();\n\t\tif (key === \"ArrowRight\") currentPiece.moveRight();\n\t\tif (key === \"ArrowDown\") currentPiece.moveDown();\n\t\tif (key === \"l\") currentPiece.lock();\n\t\tif (key === \"p\") penalty();\n\t}\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\ttextAlign: \"center\",\n\t\t\t}}\n\t\t>\n\t\t\t<canvas\n\t\t\t\tid=\"canvas\"\n\t\t\t\tref={canvasRef}\n\t\t\t\twidth={COLS * BLOCK}\n\t\t\t\theight={ROWS * BLOCK}\n\t\t\t\tstyle={{\n\t\t\t\t\tborder: \"2px solid #000\",\n\t\t\t\t\tmarginTop: 10,\n\t\t\t\t}}\n\t\t\t></canvas>\n\t\t</div>\n\t);\n};\n\nexport default GameCanvas;\n"]},"metadata":{},"sourceType":"module"}